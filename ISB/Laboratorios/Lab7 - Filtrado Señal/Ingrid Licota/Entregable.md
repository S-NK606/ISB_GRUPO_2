Nombre: Ingrid Pierina Licota Ocaña

# Filtros usados:

1. **Para las señales EMG**
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/filtro_emg_blackman.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/filtro_emg_hamming.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/filtro_emg_hann.png" width="700" height="300"></p></p>
   
2. **Para las señales ECG**
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/filtro_ecg_blackman.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/Filtro_ecg_hamming.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/filtro_ecg_hann.png" width="700" height="300"></p></p>

# Análisis de señales:

1. **Gráfica en el dominio del tiempo**.
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a1.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a2.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a7.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a12.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b1.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b2.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b7.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b12.png" width="700" height="300"></p></p>
   
2. **Gráfica en el dominio de la frecuencia**.
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a3.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a8.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a13.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b3.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b8.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b13.png" width="700" height="300"></p></p>
   
3. **Transformada corta de Fourier (opcional)**.
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a4.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a9.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a14.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b4.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b9.png" width="700" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b14.png" width="700" height="300"></p></p>

# Análisis del filtro:

1. **Diagrama de polos y ceros**.
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a6.png" width="300" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b6.png" width="300" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a11.png" width="300" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b11.png" width="300" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a16.png" width="300" height="300"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b16.png" width="300" height="300"></p></p>
   
2. **Diagrama de Bode** (magnitud y fase).
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a5.png" width="700" height="700"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b5.png" width="700" height="700"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a10.png" width="700" height="700"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b10.png" width="700" height="700"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/a15.png" width="700" height="700"></p></p>
   <p align="center"><img src="/ISB/Laboratorios/Lab7 - Filtrado Señal/Ingrid Licota/Imagenes/b15.png" width="700" height="700"></p></p>

# Justificación:
Se utilizaron esos filtros, debido a que son los más utilizados en el filtrado de señales. Ademas, los filtros FIR producen menos variaciones en las frecuencias al ser mas estables.

# Codigo
Para EMG
```
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.signal import lfilter, freqz, tf2zpk, stft, butter
import os

# Función para graficar STFT (Transformada Corta de Fourier)
def plot_stft(signal, fs, title="STFT"):
    f, t, Zxx = stft(signal, fs=fs, nperseg=256)
    plt.figure(figsize=(10, 4))
    plt.pcolormesh(t, f, np.abs(Zxx), shading='gouraud')
    plt.title(f"STFT - {title}")
    plt.ylabel('Frecuencia [Hz]')
    plt.xlabel('Tiempo [s]')
    plt.ylim([0, 200])  # Límite de frecuencia
    plt.colorbar(label="Magnitud")
    plt.show()

# Función para graficar diagrama de Bode (Magnitud y Fase)
def plot_bode(filter_coeffs, fs):
    w, h = freqz(filter_coeffs, worN=8000)
    w = w * fs / (2 * np.pi)  # Convertir a Hz

    plt.figure(figsize=(10, 6))

    # Magnitud en decibelios
    plt.subplot(2, 1, 1)
    plt.plot(w, 20 * np.log10(abs(h)), 'b')
    plt.title('Diagrama de Bode')
    plt.ylabel('Magnitud [dB]')
    plt.grid(True)

    # Fase
    plt.subplot(2, 1, 2)
    plt.plot(w, np.angle(h), 'b')
    plt.ylabel('Fase [radianes]')
    plt.xlabel('Frecuencia [Hz]')
    plt.grid(True)

    plt.tight_layout()
    plt.show()

# Función para graficar la FFT de una señal
def plot_fft(signal, fs, title="FFT"):
    N = len(signal)  # Longitud de la señal
    fft_values = np.fft.fft(signal)  # Calcular la FFT
    fft_values = fft_values[:N // 2]  # Tomar solo la mitad de las frecuencias (frecuencias positivas)
    
    # Frecuencias correspondientes
    freqs = np.fft.fftfreq(N, 1/fs)[:N // 2]
    
    # Magnitud en decibelios
    magnitude = np.abs(fft_values)
    magnitude_db = 20 * np.log10(magnitude)
    
    # Graficar FFT
    plt.figure(figsize=(10, 4))
    plt.plot(freqs, magnitude_db, label="FFT Magnitude")
    plt.title(f"FFT - {title}")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("Magnitud [dB]")
    plt.grid(True)
    plt.xlim([0, fs / 2])  # Mostrar solo hasta la mitad de la frecuencia de muestreo (Nyquist)
    plt.legend(loc="upper right")
    plt.show()

# Función para graficar el diagrama de polos y ceros
def zplane(b, a):
    """Grafica el diagrama de polos y ceros de un sistema"""
    plt.figure(figsize=(6, 6))

    # Asegurarse de que 'b' y 'a' sean arrays de NumPy
    b = np.array(b)
    a = np.array(a)

    # Normalización de los coeficientes si a[0] no es 1
    b = b / a[0]
    a = a / a[0]

    # Polos y ceros
    zeros = np.roots(b)
    poles = np.roots(a)

    # Crear el círculo unitario
    unit_circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='dotted')
    plt.gca().add_artist(unit_circle)

    # Graficar los ceros y polos
    plt.plot(np.real(zeros), np.imag(zeros), 'go', label='Ceros')
    plt.plot(np.real(poles), np.imag(poles), 'rx', label='Polos')

    plt.axvline(0, color='k', linestyle='dotted')
    plt.axhline(0, color='k', linestyle='dotted')

    plt.xlabel('Parte Real')
    plt.ylabel('Parte Imaginaria')
    plt.title('Diagrama de Polos y Ceros')
    plt.legend()

    plt.grid(True)
    plt.axis('equal')
    plt.show()

# Parámetros de muestreo
Fs = 1000  # Frecuencia de muestreo
Ts = 1 / Fs  # Período de muestreo

# Definir el intervalo de tiempo (en segundos) para enfocar de 10 a 20 segundos
start_time = 10  # Inicio del rango de tiempo
end_time = 20   # Final del rango de tiempo

# Lista de rutas de archivos de filtros
filter_paths = [
    'C:\\Users\\Ingrid\\Downloads\\Blackman_eMg_filter.csv',
    'C:\\Users\\Ingrid\\Downloads\\Hamming_eMg_filter.csv',
    'C:\\Users\\Ingrid\\Downloads\\Hann_eMg_filter.csv'
]

# Diccionario para almacenar los filtros cargados
filters = {}
filter_names = ["Filtro Blackman", "Filtro Hamming", "Filtro Hanning"]

# Cargar los filtros desde los archivos CSV
for idx, filter_path in enumerate(filter_paths):
    filters[filter_names[idx]] = np.array(pd.read_csv(filter_path).iloc[:, 0])

# Lista de archivos de señales a procesar
file_paths = [
     "C:\\Users\\Ingrid\\Downloads\\oposicion_leve.txt",
    "C:\\Users\\Ingrid\\Downloads\\oposicion_fuerte.txt",
    "C:\\Users\\Ingrid\\Downloads\\dedo_en_reposo.txt"
]

nombres = ["Dedo con oposición leve","Dedo con oposición fuerte","Dedo en reposo"]

# Procesar cada archivo de señal
for idx, file_path in enumerate(file_paths):
    # Leer archivo, ignorando las líneas de encabezado
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # Buscar la línea que contiene 'EndOfHeader'
    data_start = None
    for i, line in enumerate(lines):
        if 'EndOfHeader' in line:
            data_start = i + 1
            break

    if data_start is None:
        raise ValueError(f"No se encontró 'EndOfHeader' en el archivo {file_path}.")

    # Extraer las líneas de datos
    data_lines = lines[data_start:]

    # Convertir las líneas de datos a un array de NumPy
    data = np.array([list(map(float, line.strip().split('\t'))) for line in data_lines])

    # Extraer la señal EMG (última columna en los datos)
    signal1 = data[:, 5]

    # Crear el vector de tiempo
    time = np.arange(0, len(signal1)) / Fs  # Vector de tiempo completo

    # Encontrar los índices correspondientes al rango de tiempo definido (10 a 20 segundos)
    start_idx = int(start_time * Fs)
    end_idx = int(end_time * Fs)

    # Recortar la señal y el vector de tiempo
    signal1_focus = signal1[start_idx:end_idx]
    time_focus = time[start_idx:end_idx]

    # Graficar la señal original enfocada entre 10 y 20 segundos
    plt.figure(figsize=(10, 4))
    plt.plot(time_focus, signal1_focus, label=f"Señal original (enfocada) - {nombres[idx]}")
    plt.grid(True)
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Amplitud")
    plt.legend(loc="upper right")
    plt.title(f"Señal original ECG - {nombres[idx]} (Enfocada entre {start_time}s y {end_time}s)")
    plt.show()

    # Aplicar y graficar para cada filtro
    for filter_name, filter_coeffs in filters.items():
        # Aplicar el filtro
        signal1_filtered = lfilter(filter_coeffs, 1.0, signal1_focus)

        # Graficar la señal filtrada en el dominio del tiempo
        plt.figure(figsize=(10, 4))
        plt.plot(time_focus, signal1_filtered, label=f"Señal filtrada con {filter_name} - {nombres[idx]}")
        plt.grid(True)
        plt.xlabel("Tiempo (s)")
        plt.ylabel("Amplitud")
        plt.legend(loc="upper right")
        plt.title(f"Señal ECG filtrada - {filter_name}")
        plt.show()

        # Graficar FFT de la señal filtrada
        plot_fft(signal1_filtered, Fs, title=f"{filter_name} - {nombres[idx]}")

        # Graficar STFT de la señal filtrada
        plot_stft(signal1_filtered, Fs, title=f"{filter_name} - {nombres[idx]}")

        # Graficar diagrama de Bode del filtro
        plot_bode(filter_coeffs, Fs)

        # Graficar diagrama de polos y ceros del filtro
        zplane(filter_coeffs, [1.0])
```

Para ECG
```
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.signal import lfilter, freqz, tf2zpk, stft, butter
import os

# Función para graficar STFT (Transformada Corta de Fourier)
def plot_stft(signal, fs, title="STFT"):
    f, t, Zxx = stft(signal, fs=fs, nperseg=256)
    plt.figure(figsize=(10, 4))
    plt.pcolormesh(t, f, np.abs(Zxx), shading='gouraud')
    plt.title(f"STFT - {title}")
    plt.ylabel('Frecuencia [Hz]')
    plt.xlabel('Tiempo [s]')
    plt.ylim([0, 200])  # Límite de frecuencia
    plt.colorbar(label="Magnitud")
    plt.show()

# Función para graficar diagrama de Bode (Magnitud y Fase)
def plot_bode(filter_coeffs, fs):
    w, h = freqz(filter_coeffs, worN=8000)
    w = w * fs / (2 * np.pi)  # Convertir a Hz

    plt.figure(figsize=(10, 6))

    # Magnitud en decibelios
    plt.subplot(2, 1, 1)
    plt.plot(w, 20 * np.log10(abs(h)), 'b')
    plt.title('Diagrama de Bode')
    plt.ylabel('Magnitud [dB]')
    plt.grid(True)

    # Fase
    plt.subplot(2, 1, 2)
    plt.plot(w, np.angle(h), 'b')
    plt.ylabel('Fase [radianes]')
    plt.xlabel('Frecuencia [Hz]')
    plt.grid(True)

    plt.tight_layout()
    plt.show()

# Función para graficar la FFT de una señal
def plot_fft(signal, fs, title="FFT"):
    N = len(signal)  # Longitud de la señal
    fft_values = np.fft.fft(signal)  # Calcular la FFT
    fft_values = fft_values[:N // 2]  # Tomar solo la mitad de las frecuencias (frecuencias positivas)
    
    # Frecuencias correspondientes
    freqs = np.fft.fftfreq(N, 1/fs)[:N // 2]
    
    # Magnitud en decibelios
    magnitude = np.abs(fft_values)
    magnitude_db = 20 * np.log10(magnitude)
    
    # Graficar FFT
    plt.figure(figsize=(10, 4))
    plt.plot(freqs, magnitude_db, label="FFT Magnitude")
    plt.title(f"FFT - {title}")
    plt.xlabel("Frecuencia [Hz]")
    plt.ylabel("Magnitud [dB]")
    plt.grid(True)
    plt.xlim([0, fs / 2])  # Mostrar solo hasta la mitad de la frecuencia de muestreo (Nyquist)
    plt.legend(loc="upper right")
    plt.show()

# Función para graficar el diagrama de polos y ceros
def zplane(b, a):
    """Grafica el diagrama de polos y ceros de un sistema"""
    plt.figure(figsize=(6, 6))

    # Asegurarse de que 'b' y 'a' sean arrays de NumPy
    b = np.array(b)
    a = np.array(a)

    # Normalización de los coeficientes si a[0] no es 1
    b = b / a[0]
    a = a / a[0]

    # Polos y ceros
    zeros = np.roots(b)
    poles = np.roots(a)

    # Crear el círculo unitario
    unit_circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='dotted')
    plt.gca().add_artist(unit_circle)

    # Graficar los ceros y polos
    plt.plot(np.real(zeros), np.imag(zeros), 'go', label='Ceros')
    plt.plot(np.real(poles), np.imag(poles), 'rx', label='Polos')

    plt.axvline(0, color='k', linestyle='dotted')
    plt.axhline(0, color='k', linestyle='dotted')

    plt.xlabel('Parte Real')
    plt.ylabel('Parte Imaginaria')
    plt.title('Diagrama de Polos y Ceros')
    plt.legend()

    plt.grid(True)
    plt.axis('equal')
    plt.show()

# Parámetros de muestreo
Fs = 1000  # Frecuencia de muestreo
Ts = 1 / Fs  # Período de muestreo

# Definir el intervalo de tiempo (en segundos) para enfocar de 10 a 20 segundos
start_time = 10  # Inicio del rango de tiempo
end_time = 20   # Final del rango de tiempo

# Lista de rutas de archivos de filtros
filter_paths = [
    'C:\\Users\\Ingrid\\Downloads\\Blackman_ecg_filter.csv',
    'C:\\Users\\Ingrid\\Downloads\\Hamming_ecg_filter.csv',
    'C:\\Users\\Ingrid\\Downloads\\Hann_ecg_filter.csv'
]

# Diccionario para almacenar los filtros cargados
filters = {}
filter_names = ["Filtro Blackman", "Filtro Hamming", "Filtro Hanning"]

# Cargar los filtros desde los archivos CSV
for idx, filter_path in enumerate(filter_paths):
    filters[filter_names[idx]] = np.array(pd.read_csv(filter_path).iloc[:, 0])

# Lista de archivos de señales a procesar
file_paths = [
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Estado_con_Respiracion_I_deriv.txt",
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Estado_con_Respiracion_II_deriv.txt",
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Estado_con_Respiracion_III_deriv.txt",
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Ejercicio_I_deriv.txt",
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Ejercicio_II_deriv.txt",
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Ejercicio_III_deriv.txt",
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Simulacion_120bpm.txt",
    "C:\\Users\\Ingrid\\Downloads\\Señales_2\\Simulacion_150bpm.txt"
]

nombres = ["Estado con respiración (1ra derivación)", "Estado con respiración (2da derivación)", "Estado con respiración (3ra derivación)",
           "Ejercicio (1ra derivación)", "Ejercicio (2da derivación)", "Ejercicio (3ra derivación)",
           "Simulación a 120 bpm", "Simulación a 150 bpm"]

# Procesar cada archivo de señal
for idx, file_path in enumerate(file_paths):
    # Leer archivo, ignorando las líneas de encabezado
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # Buscar la línea que contiene 'EndOfHeader'
    data_start = None
    for i, line in enumerate(lines):
        if 'EndOfHeader' in line:
            data_start = i + 1
            break

    if data_start is None:
        raise ValueError(f"No se encontró 'EndOfHeader' en el archivo {file_path}.")

    # Extraer las líneas de datos
    data_lines = lines[data_start:]

    # Convertir las líneas de datos a un array de NumPy
    data = np.array([list(map(float, line.strip().split('\t'))) for line in data_lines])

    # Extraer la señal ECG (última columna en los datos)
    signal1 = data[:, 5]

    # Crear el vector de tiempo
    time = np.arange(0, len(signal1)) / Fs  # Vector de tiempo completo

    # Encontrar los índices correspondientes al rango de tiempo definido (10 a 20 segundos)
    start_idx = int(start_time * Fs)
    end_idx = int(end_time * Fs)

    # Recortar la señal y el vector de tiempo
    signal1_focus = signal1[start_idx:end_idx]
    time_focus = time[start_idx:end_idx]

    # Graficar la señal original enfocada entre 10 y 20 segundos
    plt.figure(figsize=(10, 4))
    plt.plot(time_focus, signal1_focus, label=f"Señal original (enfocada) - {nombres[idx]}")
    plt.grid(True)
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Amplitud")
    plt.legend(loc="upper right")
    plt.title(f"Señal original ECG - {nombres[idx]} (Enfocada entre {start_time}s y {end_time}s)")
    plt.show()

    # Aplicar y graficar para cada filtro
    for filter_name, filter_coeffs in filters.items():
        # Aplicar el filtro
        signal1_filtered = lfilter(filter_coeffs, 1.0, signal1_focus)

        # Graficar la señal filtrada en el dominio del tiempo
        plt.figure(figsize=(10, 4))
        plt.plot(time_focus, signal1_filtered, label=f"Señal filtrada con {filter_name} - {nombres[idx]}")
        plt.grid(True)
        plt.xlabel("Tiempo (s)")
        plt.ylabel("Amplitud")
        plt.legend(loc="upper right")
        plt.title(f"Señal ECG filtrada - {filter_name}")
        plt.show()

        # Graficar FFT de la señal filtrada
        plot_fft(signal1_filtered, Fs, title=f"{filter_name} - {nombres[idx]}")

        # Graficar STFT de la señal filtrada
        plot_stft(signal1_filtered, Fs, title=f"{filter_name} - {nombres[idx]}")

        # Graficar diagrama de Bode del filtro
        plot_bode(filter_coeffs, Fs)

        # Graficar diagrama de polos y ceros del filtro
        zplane(filter_coeffs, [1.0])
```
